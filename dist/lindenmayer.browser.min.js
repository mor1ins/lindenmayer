var LSystem=function(){"use strict";function t(t){var s,i=t[0].match(/(.+)<(.)/),r=t[0].match(/(.)>(.+)/);if(null===i&&null===r)return t;var o=t[1].successor||t[1].successors?t[1]:{successor:t[1]};return null!==i&&(s=i[2],o.leftCtx=i[1]),null!==r&&(s=r[1],o.rightCtx=r[2]),[s,o]}function s(t){if("string"!=typeof t&&t instanceof String==!1)return t;var s=[],i=t,r=Array.isArray(i),o=0;for(i=r?i:i[Symbol.iterator]();;){var e;if(r){if(o>=i.length)break;e=i[o++]}else{if((o=i.next()).done)break;e=o.value}var n=e;s.push({symbol:n})}return s}function i(t,i){return t[1]=function t(i,r){if(i.hasOwnProperty("successors"))for(var o=0;o<i.successors.length;o++)i.successors[o]=t(i.successors[o],r);else!1===i.hasOwnProperty("successor")&&(i={successor:i});return r&&i.hasOwnProperty("successor")&&(i.successor=s(i.successor)),i}(t[1],i),t}var LSystem=function(){function LSystem(t){var s=t.axiom,i=void 0===s?"":s,r=t.productions,o=t.finals,e=t.branchSymbols,n=void 0===e?"[]":e,a=t.ignoredSymbols,c=void 0===a?"+-&^/|\\":a,h=t.allowClassicSyntax,u=void 0===h||h,l=t.classicParametricSyntax,f=void 0!==l&&l,d=t.forceObjects,m=void 0!==d&&d,v=t.debug,y=void 0!==v&&v;this.ignoredSymbols=c,this.debug=y,this.branchSymbols=n,this.allowClassicSyntax=u,this.classicParametricSyntax=f,this.forceObjects=m,this.setAxiom(i),this.clearProductions(),r&&this.setProductions(r),o&&this.setFinals(o)}var r=LSystem.prototype;return r.setAxiom=function(t){this.axiom=this.forceObjects?s(t):t},r.getRaw=function(){return this.axiom},r.getString=function(t){return void 0===t&&(t=!0),"string"==typeof this.axiom?this.axiom:!0===t?this.axiom.reduce(function(t,s){if(void 0===s.symbol)throw console.log("found:",s),new Error("L-Systems that use only objects as symbols (eg: {symbol: 'F', params: []}), cant use string symbols (eg. 'F')! Check if you always return objects in your productions and no strings.");return t+s.symbol},""):JSON.stringify(this.axiom)},r.setProduction=function(s,r,o){void 0===o&&(o=!1);var e=[s,r];if(void 0===e)throw new Error("no production specified.");if(r.successor&&r.successors)throw new Error('You can not have both a "successor" and a "successors" field in your production!');if(!0===this.allowClassicSyntax&&(e=t(e)),(e=i(e,this.forceObjects))[1].isStochastic=void 0!==e[1].successors&&e[1].successors.every(function(t){return void 0!==t.weight}),e[1].isStochastic){e[1].weightSum=0;var n=e[1].successors,a=Array.isArray(n),c=0;for(n=a?n:n[Symbol.iterator]();;){var h;if(a){if(c>=n.length)break;h=n[c++]}else{if((c=n.next()).done)break;h=c.value}var u=h;e[1].weightSum+=u.weight}}var l=e[0];if(!0===o&&this.productions.has(l)){var f=this.productions.get(l),d=f.successor,m=f.successors;d&&!m&&(f={successors:[f]}),f.successors.push(e[1]),this.productions.set(l,f)}else this.productions.set(l,e[1])},r.setProductions=function(t){if(void 0===t)throw new Error("no production specified.");this.clearProductions();for(var s=0,i=Object.entries(t);s<i.length;s++){var r=i[s],o=r[0],e=r[1];this.setProduction(o,e,!0)}},r.clearProductions=function(){this.productions=new Map},r.setFinal=function(t,s){var i=[t,s];if(void 0===i)throw new Error("no final specified.");this.finals.set(i[0],i[1])},r.setFinals=function(t){if(void 0===t)throw new Error("no finals specified.");for(var s in this.finals=new Map,t)t.hasOwnProperty(s)&&this.setFinal(s,t[s])},r.getProductionResult=function(t,s,i,r,o){void 0===o&&(o=!1);var e=void 0!==t.leftCtx||void 0!==t.rightCtx,n=!1,a=!0;if(void 0!==t.condition&&!1===t.condition({index:s,currentAxiom:this.axiom,part:i,params:r})?a=!1:e&&(void 0!==t.leftCtx&&void 0!==t.rightCtx?a=this.match({direction:"left",match:t.leftCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result&&this.match({direction:"right",match:t.rightCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result:void 0!==t.leftCtx?a=this.match({direction:"left",match:t.leftCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result:void 0!==t.rightCtx&&(a=this.match({direction:"right",match:t.rightCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result)),!1===a)n=!1;else if(t.successors){var c,h;t.isStochastic&&(h=Math.random()*t.weightSum,c=0);var u=t.successors,l=Array.isArray(u),f=0;for(u=l?u:u[Symbol.iterator]();;){var d;if(l){if(f>=u.length)break;d=u[f++]}else{if((f=u.next()).done)break;d=f.value}var m=d;if(!(t.isStochastic&&(c+=m.weight)<h)){var v=this.getProductionResult(m,s,i,r,!0);if(void 0!==v&&!1!==v){n=v;break}}}}else n="function"==typeof t.successor?t.successor({index:s,currentAxiom:this.axiom,part:i,params:r}):t.successor;return n||(o?n:i)},r.applyProductions=function(){var t="string"==typeof this.axiom?"":[],s=0,i=this.axiom,r=Array.isArray(i),o=0;for(i=r?i:i[Symbol.iterator]();;){var e;if(r){if(o>=i.length)break;e=i[o++]}else{if((o=i.next()).done)break;e=o.value}var n=e,a=n.symbol||n,c=n.params||[],h=n;if(this.productions.has(a)){var u=this.productions.get(a);h=this.getProductionResult(u,s,n,c)}if("string"==typeof t)t+=h;else if(h instanceof Array){var l;(l=t).push.apply(l,h)}else t.push(h);s++}return this.axiom=t,t},r.iterate=function(t){var s;void 0===t&&(t=1),this.iterations=t;for(var i=0;i<t;i++)s=this.applyProductions();return s},r.final=function(t){var s=0,i=this.axiom,r=Array.isArray(i),o=0;for(i=r?i:i[Symbol.iterator]();;){var e;if(r){if(o>=i.length)break;e=i[o++]}else{if((o=i.next()).done)break;e=o.value}var n=e,a=n;if("object"==typeof n&&n.symbol&&(a=n.symbol),this.finals.has(a)){var c=this.finals.get(a),h=typeof c;if("function"!==h)throw Error("'"+a+"' has an object for a final function. But it is __not a function__ but a "+h+"!");c({index:s,part:n},t)}s++}},r.match=function(t){var s=t.axiom_,i=t.match,r=t.ignoredSymbols,o=t.branchSymbols,e=t.index,n=t.direction,a=0,c=0;s=s||this.axiom,void 0===o&&(o=void 0!==this.branchSymbols?this.branchSymbols:[]),void 0===r&&(r=void 0!==this.ignoredSymbols?this.ignoredSymbols:[]);var h,u,l,f,d,m,v,y=[];if("right"===n){if(f=m=1,l=e+1,d=0,v=i.length,o.length>0){var b=o;h=b[0],u=b[1]}}else{if("left"!==n)throw Error(n,"is not a valid direction for matching.");if(f=m=-1,l=e-1,d=i.length-1,v=-1,o.length>0){var g=o;u=g[0],h=g[1]}}for(;l<s.length&&l>=0;l+=f){var p=s[l].symbol||s[l],x=i[d];if(p===x){if((0===a||c>0)&&(p===h?(c++,a++,d+=m):p===u?(c=Math.max(0,c-1),a=Math.max(0,a-1),0===c&&(d+=m)):(y.push(l),d+=m)),d===v)return{result:!0,matchIndices:y}}else if(p===h)a++,c>0&&c++;else if(p===u)a=Math.max(0,a-1),c>0&&(c=Math.max(0,c-1));else if((0===a||c>0&&x!==u)&&!1===r.includes(p))return{result:!1,matchIndices:y}}return{result:!1,matchIndices:y}},LSystem}();return LSystem.getStringResult=LSystem.getString,LSystem.transformClassicStochasticProductions=function(t){return function(){for(var s=t,i=s.length,r=Math.random(),o=0;o<i;o++)if(r<=(o+1)/i)return s[o];console.error("Should have returned a result of the list, something is wrong here with the random numbers?.")}},LSystem.transformClassicCSProduction=t,LSystem.transformClassicParametricAxiom=function(t){for(var s=t.replace(/\s+/g,"").split(/[\(\)]/),i=[],r=0;r<s.length-1;r+=2){var o=s[r+1].split(",").map(Number);i.push({symbol:s[r],params:o})}},LSystem.testClassicParametricSyntax=function(t){return/\(.+\)/.test(t)},LSystem}();
