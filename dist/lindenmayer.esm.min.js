function s(s){var t,i=s[0].match(/(.+)<(.)/),r=s[0].match(/(.)>(.+)/);if(null===i&&null===r)return s;var o=s[1].successor||s[1].successors?s[1]:{successor:s[1]};return null!==i&&(t=i[2],o.leftCtx=i[1]),null!==r&&(t=r[1],o.rightCtx=r[2]),[t,o]}function t(s){if("string"!=typeof s&&s instanceof String==!1)return s;var t=[];for(var i of s)t.push({symbol:i});return t}function i(s,i){return s[1]=function s(i,r){if(i.hasOwnProperty("successors"))for(var o=0;o<i.successors.length;o++)i.successors[o]=s(i.successors[o],r);else!1===i.hasOwnProperty("successor")&&(i={successor:i});return r&&i.hasOwnProperty("successor")&&(i.successor=t(i.successor)),i}(s[1],i),s}class LSystem{constructor(s){var{axiom:t="",productions:i,finals:r,branchSymbols:o="[]",ignoredSymbols:e="+-&^/|\\",allowClassicSyntax:n=!0,classicParametricSyntax:a=!1,forceObjects:c=!1,debug:h=!1}=s;this.ignoredSymbols=e,this.debug=h,this.branchSymbols=o,this.allowClassicSyntax=n,this.classicParametricSyntax=a,this.forceObjects=c,this.setAxiom(t),this.clearProductions(),i&&this.setProductions(i),r&&this.setFinals(r)}setAxiom(s){this.axiom=this.forceObjects?t(s):s}getRaw(){return this.axiom}getString(){var s=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return"string"==typeof this.axiom?this.axiom:!0===s?this.axiom.reduce((s,t)=>{if(void 0===t.symbol)throw console.log("found:",t),new Error("L-Systems that use only objects as symbols (eg: {symbol: 'F', params: []}), cant use string symbols (eg. 'F')! Check if you always return objects in your productions and no strings.");return s+t.symbol},""):JSON.stringify(this.axiom)}setProduction(t,r){var o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],e=[t,r];if(void 0===e)throw new Error("no production specified.");if(r.successor&&r.successors)throw new Error('You can not have both a "successor" and a "successors" field in your production!');if(!0===this.allowClassicSyntax&&(e=s(e)),(e=i(e,this.forceObjects))[1].isStochastic=void 0!==e[1].successors&&e[1].successors.every(s=>void 0!==s.weight),e[1].isStochastic)for(var n of(e[1].weightSum=0,e[1].successors))e[1].weightSum+=n.weight;var a=e[0];if(!0===o&&this.productions.has(a)){var c=this.productions.get(a),h=c.successor,l=c.successors;h&&!l&&(c={successors:[c]}),c.successors.push(e[1]),this.productions.set(a,c)}else this.productions.set(a,e[1])}setProductions(s){if(void 0===s)throw new Error("no production specified.");for(var[t,i]of(this.clearProductions(),Object.entries(s)))this.setProduction(t,i,!0)}clearProductions(){this.productions=new Map}setFinal(s,t){var i=[s,t];if(void 0===i)throw new Error("no final specified.");this.finals.set(i[0],i[1])}setFinals(s){if(void 0===s)throw new Error("no finals specified.");for(var t in this.finals=new Map,s)s.hasOwnProperty(t)&&this.setFinal(t,s[t])}getProductionResult(s,t,i,r){var o=arguments.length>4&&void 0!==arguments[4]&&arguments[4],e=void 0!==s.leftCtx||void 0!==s.rightCtx,n=!1,a=!0;if(void 0!==s.condition&&!1===s.condition({index:t,currentAxiom:this.axiom,part:i,params:r})?a=!1:e&&(void 0!==s.leftCtx&&void 0!==s.rightCtx?a=this.match({direction:"left",match:s.leftCtx,index:t,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result&&this.match({direction:"right",match:s.rightCtx,index:t,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result:void 0!==s.leftCtx?a=this.match({direction:"left",match:s.leftCtx,index:t,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result:void 0!==s.rightCtx&&(a=this.match({direction:"right",match:s.rightCtx,index:t,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result)),!1===a)n=!1;else if(s.successors){var c,h;for(var l of(s.isStochastic&&(h=Math.random()*s.weightSum,c=0),s.successors))if(!(s.isStochastic&&(c+=l.weight)<h)){var u=this.getProductionResult(l,t,i,r,!0);if(void 0!==u&&!1!==u){n=u;break}}}else n="function"==typeof s.successor?s.successor({index:t,currentAxiom:this.axiom,part:i,params:r}):s.successor;return n||(o?n:i)}applyProductions(){var s="string"==typeof this.axiom?"":[],t=0;for(var i of this.axiom){var r=i.symbol||i,o=i.params||[],e=i;if(this.productions.has(r)){var n=this.productions.get(r);e=this.getProductionResult(n,t,i,o)}"string"==typeof s?s+=e:e instanceof Array?s.push(...e):s.push(e),t++}return this.axiom=s,s}iterate(){var s,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;this.iterations=t;for(var i=0;i<t;i++)s=this.applyProductions();return s}final(s){var t=0;for(var i of this.axiom){var r=i;if("object"==typeof i&&i.symbol&&(r=i.symbol),this.finals.has(r)){var o=this.finals.get(r),e=typeof o;if("function"!==e)throw Error("'"+r+"' has an object for a final function. But it is __not a function__ but a "+e+"!");o({index:t,part:i},s)}t++}}match(s){var{axiom_:t,match:i,ignoredSymbols:r,branchSymbols:o,index:e,direction:n}=s,a=0,c=0;t=t||this.axiom,void 0===o&&(o=void 0!==this.branchSymbols?this.branchSymbols:[]),void 0===r&&(r=void 0!==this.ignoredSymbols?this.ignoredSymbols:[]);var h,l,u,f,d,m,g,b=[];if("right"===n)f=m=1,u=e+1,d=0,g=i.length,o.length>0&&([h,l]=o);else{if("left"!==n)throw Error(n,"is not a valid direction for matching.");f=m=-1,u=e-1,d=i.length-1,g=-1,o.length>0&&([l,h]=o)}for(;u<t.length&&u>=0;u+=f){var y=t[u].symbol||t[u],v=i[d];if(y===v){if((0===a||c>0)&&(y===h?(c++,a++,d+=m):y===l?(c=Math.max(0,c-1),a=Math.max(0,a-1),0===c&&(d+=m)):(b.push(u),d+=m)),d===g)return{result:!0,matchIndices:b}}else if(y===h)a++,c>0&&c++;else if(y===l)a=Math.max(0,a-1),c>0&&(c=Math.max(0,c-1));else if((0===a||c>0&&v!==l)&&!1===r.includes(y))return{result:!1,matchIndices:b}}return{result:!1,matchIndices:b}}}LSystem.getStringResult=LSystem.getString,LSystem.transformClassicStochasticProductions=function(s){return function(){for(var t=s,i=t.length,r=Math.random(),o=0;o<i;o++){if(r<=(o+1)/i)return t[o]}console.error("Should have returned a result of the list, something is wrong here with the random numbers?.")}},LSystem.transformClassicCSProduction=s,LSystem.transformClassicParametricAxiom=function(s){for(var t=s.replace(/\s+/g,"").split(/[\(\)]/),i=[],r=0;r<t.length-1;r+=2){var o=t[r+1].split(",").map(Number);i.push({symbol:t[r],params:o})}},LSystem.testClassicParametricSyntax=function(s){return/\(.+\)/.test(s)};export default LSystem;
