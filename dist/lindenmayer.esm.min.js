function t(t){let s,i=t[0].match(/(.+)<(.)/),o=t[0].match(/(.)>(.+)/);if(null===i&&null===o)return t;let e=t[1].successor||t[1].successors?t[1]:{successor:t[1]};return null!==i&&(s=i[2],e.leftCtx=i[1]),null!==o&&(s=o[1],e.rightCtx=o[2]),[s,e]}function s(t){if("string"!=typeof t&&t instanceof String==!1)return t;let s=[];for(let i of t)s.push({symbol:i});return s}function i(t,i){return t[1]=function t(i,o){if(i.hasOwnProperty("successors"))for(var e=0;e<i.successors.length;e++)i.successors[e]=t(i.successors[e],o);else!1===i.hasOwnProperty("successor")&&(i={successor:i});return o&&i.hasOwnProperty("successor")&&(i.successor=s(i.successor)),i}(t[1],i),t}class LSystem{constructor(t){let{axiom:s="",productions:i,finals:o,branchSymbols:e="[]",ignoredSymbols:r="+-&^/|\\",allowClassicSyntax:n=!0,classicParametricSyntax:c=!1,forceObjects:l=!1,debug:a=!1}=t;this.ignoredSymbols=r,this.debug=a,this.branchSymbols=e,this.allowClassicSyntax=n,this.classicParametricSyntax=c,this.forceObjects=l,this.setAxiom(s),this.clearProductions(),i&&this.setProductions(i),o&&this.setFinals(o)}setAxiom(t){this.axiom=this.forceObjects?s(t):t}getRaw(){return this.axiom}getString(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return"string"==typeof this.axiom?this.axiom:!0===t?this.axiom.reduce((t,s)=>{if(void 0===s.symbol)throw console.log("found:",s),new Error("L-Systems that use only objects as symbols (eg: {symbol: 'F', params: []}), cant use string symbols (eg. 'F')! Check if you always return objects in your productions and no strings.");return t+s.symbol},""):JSON.stringify(this.axiom)}setProduction(s,o){let e=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=[s,o];if(void 0===r)throw new Error("no production specified.");if(o.successor&&o.successors)throw new Error('You can not have both a "successor" and a "successors" field in your production!');if(!0===this.allowClassicSyntax&&(r=t(r)),(r=i(r,this.forceObjects))[1].isStochastic=void 0!==r[1].successors&&r[1].successors.every(t=>void 0!==t.weight),r[1].isStochastic){r[1].weightSum=0;for(let t of r[1].successors)r[1].weightSum+=t.weight}let n=r[0];if(!0===e&&this.productions.has(n)){let t=this.productions.get(n),s=t.successor,i=t.successors;s&&!i&&(t={successors:[t]}),t.successors.push(r[1]),this.productions.set(n,t)}else this.productions.set(n,r[1])}setProductions(t){if(void 0===t)throw new Error("no production specified.");this.clearProductions();for(let[s,i]of Object.entries(t))this.setProduction(s,i,!0)}clearProductions(){this.productions=new Map}setFinal(t,s){let i=[t,s];if(void 0===i)throw new Error("no final specified.");this.finals.set(i[0],i[1])}setFinals(t){if(void 0===t)throw new Error("no finals specified.");this.finals=new Map;for(let s in t)t.hasOwnProperty(s)&&this.setFinal(s,t[s])}getProductionResult(t,s,i,o){let e=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=void 0!==t.leftCtx||void 0!==t.rightCtx,n=!1,c=!0;if(void 0!==t.condition&&!1===t.condition({index:s,currentAxiom:this.axiom,part:i,params:o})?c=!1:r&&(void 0!==t.leftCtx&&void 0!==t.rightCtx?c=this.match({direction:"left",match:t.leftCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result&&this.match({direction:"right",match:t.rightCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result:void 0!==t.leftCtx?c=this.match({direction:"left",match:t.leftCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result:void 0!==t.rightCtx&&(c=this.match({direction:"right",match:t.rightCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result)),!1===c)n=!1;else if(t.successors){let e,r;t.isStochastic&&(r=Math.random()*t.weightSum,e=0);for(let c of t.successors){if(t.isStochastic&&(e+=c.weight)<r)continue;let l=this.getProductionResult(c,s,i,o,!0);if(void 0!==l&&!1!==l){n=l;break}}}else n="function"==typeof t.successor?t.successor({index:s,currentAxiom:this.axiom,part:i,params:o}):t.successor;return n||(e?n:i)}applyProductions(){let t="string"==typeof this.axiom?"":[],s=0;for(let i of this.axiom){let o=i.symbol||i,e=i.params||[],r=i;if(this.productions.has(o)){let t=this.productions.get(o);r=this.getProductionResult(t,s,i,e)}"string"==typeof t?t+=r:r instanceof Array?t.push(...r):t.push(r),s++}return this.axiom=t,t}iterate(){let t,s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;this.iterations=s;for(let i=0;i<s;i++)t=this.applyProductions();return t}final(t){let s=0;for(let i of this.axiom){let o=i;if("object"==typeof i&&i.symbol&&(o=i.symbol),this.finals.has(o)){let e=this.finals.get(o),r=typeof e;if("function"!==r)throw Error("'"+o+"' has an object for a final function. But it is __not a function__ but a "+r+"!");e({index:s,part:i},t)}s++}}match(t){let{axiom_:s,match:i,ignoredSymbols:o,branchSymbols:e,index:r,direction:n}=t,c=0,l=0;s=s||this.axiom,void 0===e&&(e=void 0!==this.branchSymbols?this.branchSymbols:[]),void 0===o&&(o=void 0!==this.ignoredSymbols?this.ignoredSymbols:[]);let a,h,u,f,d,m,g,b=[];if("right"===n)f=m=1,u=r+1,d=0,g=i.length,e.length>0&&([a,h]=e);else{if("left"!==n)throw Error(n,"is not a valid direction for matching.");f=m=-1,u=r-1,d=i.length-1,g=-1,e.length>0&&([h,a]=e)}for(;u<s.length&&u>=0;u+=f){let t=s[u].symbol||s[u],e=i[d];if(t===e){if((0===c||l>0)&&(t===a?(l++,c++,d+=m):t===h?(l=Math.max(0,l-1),c=Math.max(0,c-1),0===l&&(d+=m)):(b.push(u),d+=m)),d===g)return{result:!0,matchIndices:b}}else if(t===a)c++,l>0&&l++;else if(t===h)c=Math.max(0,c-1),l>0&&(l=Math.max(0,l-1));else if((0===c||l>0&&e!==h)&&!1===o.includes(t))return{result:!1,matchIndices:b}}return{result:!1,matchIndices:b}}}LSystem.getStringResult=LSystem.getString,LSystem.transformClassicStochasticProductions=function(t){return function(){let s=t,i=s.length,o=Math.random();for(let t=0;t<i;t++)if(o<=(t+1)/i)return s[t];console.error("Should have returned a result of the list, something is wrong here with the random numbers?.")}},LSystem.transformClassicCSProduction=t,LSystem.transformClassicParametricAxiom=function(t){let s=t.replace(/\s+/g,"").split(/[\(\)]/),i=[];for(let t=0;t<s.length-1;t+=2){let o=s[t+1].split(",").map(Number);i.push({symbol:s[t],params:o})}},LSystem.testClassicParametricSyntax=function(t){return/\(.+\)/.test(t)};export default LSystem;
